<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
  />
<title>PRACTICAL WORK 2 - Ex1</title>
  <style>
    html,
    body {
        height: 100%;
        width: 100%;
        margin: 0;
        overflow: hidden;
    }

    #c {
        width: 100%;
        height: 100%;
        display: block;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  </body>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/",
        "three/src/math/MathUtils": "https://unpkg.com/three@0.172.0/src/math/MathUtils.js"
        }
    }
</script>

  <script type="module">
    //import * as THREE from 'https://unpkg.com/three@0.172.0/build/three.module.js';
    //import { OrbitControls } from 'https://unpkg.com/three@0.172.0/examples/jsm/controls/OrbitControls.js';
    //import { GUI } from 'https://unpkg.com/three@0.172.0/examples/jsm/libs/lil-gui.module.min.js';
    

    

    // https://gist.github.com/HarryStevens/606a8e6cec5de7dd72e933c0b1b793db
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import Stats from 'three/addons/libs/stats.module.js';
    import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
    import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';


    /*body„ÅÆ‰∏ã
      <div id="scene"></div>
  <div id="stats"></div>


  */

  const scene = new THREE.Scene();
  
  const canvas = document.querySelector( '#c' );

  const renderer = (_ => {
    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor("#000");
    renderer.setPixelRatio(devicePixelRatio);
    //renderer.shadowMap.enabled = true;
    //renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;

    renderer.gammaOutput = true;
    renderer.gammaFactor = 2.2;
    //document.getElementById("scene").appendChild(renderer.domElement); // renderer
    //document.body.appendChild(renderer.domElement);
    return renderer;
  })();

  const controls = { lightIntensity: 1.5, lightDistance: 20, lightColor: "#fff" };





    let left = 0, right = 0, up = 0, down = 0;
    
    const gui = (_ => {
      const gui = new GUI();
      gui.add(controls, "lightIntensity", 0, 100).onChange(value => {
        pointLights.forEach(light => light.intensity = value);
      })
      gui.add(controls, "lightDistance", 1, 100).onChange(value => {
        pointLights.forEach(light => light.distance = value);
    });
      gui.addColor(controls, "lightColor").onChange(e => {
        pointLights.forEach(light => light.color.set(e));
        //createRectLight.color = new THREE.Color(e);
      });
      return gui;
    })();


        // 3„Å§„ÅÆ„É©„Ç§„Éà„Éë„Éç„É´„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà‰ΩçÁΩÆ
    const panelOffsets = [
        { x: -5, z: -25 }, { x: 0, z: -25 }, { x: 5, z: -25 },
        { x: -5, z: -19 }, { x: 0, z: -19 }, { x: 5, z: -19 },
        { x: -5, z: -10 }, { x: 0, z: -10 }, { x: 5, z: -10 },
        { x: -5, z: -4 }, { x: 0, z: -4 }, { x: 5, z: -4 }
    ];    

    // **ÂÖ®„Å¶„ÅÆ PointLight „ÇíÁÆ°ÁêÜ„Åô„ÇãÈÖçÂàó**
    const pointLights = [];

    const createRectLight = (panel, scene) =>{

      // PointLight===============================================================
      const pointLight = new THREE.PointLight(controls.lightColor, controls.lightIntensity, controls.lightDistance); // **Ëâ≤, Âº∑Â∫¶, Ë∑ùÈõ¢**
      //pointLight.distance = controls.lightDistance;
      pointLight.position.copy(panel.position); // **RectAreaLight„Å®Âêå„Åò‰ΩçÁΩÆ**
      pointLight.position.y += -0.5; // **Â∞ë„Åó‰∏ä„Å´ÈÖçÁΩÆ**
        
      // **„É©„Ç§„Éà„ÅÆ„Éò„É´„Éë„Éº„ÇíËøΩÂä†Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ**
      const p_lightHelper = new THREE.PointLightHelper(pointLight, 1); // 1„ÅØ„Éò„É´„Éë„Éº„ÅÆ„Çµ„Ç§„Ç∫
      scene.add(p_lightHelper);
      
      // **„É©„Ç§„Éà„ÇíÈÖçÂàó„Å´ËøΩÂä†**
      pointLights.push(pointLight);

      // **„Ç∑„Éº„É≥„Å´ËøΩÂä†**
      scene.add(pointLight);
      
      // **ÂΩ±„ÇíÊúâÂäπÂåñ**
      pointLight.castShadow = true;
      pointLight.shadow.mapSize.width = 512; //1024
      pointLight.shadow.mapSize.height = 512; //

      return pointLight;
    };
  
    const createLightPanelSet = (panelOffsets, scene) => {
      const setGroup = new THREE.Group(); // **„É©„Ç§„Éà„Çª„ÉÉ„Éà„ÅÆ„Ç∞„É´„Éº„Éó**
      const coverMat = new THREE.MeshPhongMaterial({ color: controls.lightColor }); // **ÂÖ±ÈÄö„Éû„ÉÜ„É™„Ç¢„É´**
  
      // **„É©„Ç§„Éà„ÅÆ„É™„Çπ„Éà„Çí‰øùÊåÅ**
      //const rectLights = [];
      const directLights = [];

      // 3„Å§„ÅÆ„É©„Ç§„Éà„Éë„Éç„É´„Å® `RectAreaLight` „Çí„Çª„ÉÉ„Éà„Å®„Åó„Å¶‰ΩúÊàê
      panelOffsets.forEach(offset => {
          // **„Ç´„Éê„ÉºÔºà„Éú„ÉÉ„ÇØ„ÇπÂûãÔºâ**
          const coverGeo = new THREE.BoxGeometry(4, 0.2, 1); // with, h, d
          const cover = new THREE.Mesh(coverGeo, coverMat);
          cover.position.set(offset.x, 12, offset.z);
          setGroup.add(cover);

          // **„Éë„Éç„É´„Å®Âêå„Åò‰ΩçÁΩÆ„Å´„É©„Ç§„Éà„ÇíÈÖçÁΩÆ**
          //const {rectLight, directLight} = createRectLight(cover, scene);
          const directLight = createRectLight(cover, scene);
          //rectLights.push(rectLight); // **„É™„Çπ„Éà„Å´ËøΩÂä†**
          directLights.push(directLight);

      });
  

  
      scene.add(setGroup);
      return setGroup;
  };
  
  // ‚úÖ **4„Çª„ÉÉ„Éà„Çí‰∏¶„Åπ„Çã**
  //const setPositions = [
      //{ z: 0 },{ z: 6 },{ z: 15 },{ z: 21 }
  //;
  
  const lightPanelSets = createLightPanelSet(panelOffsets, scene);


  
  
  /*
    const pointLight = (_ => {
      const light = new THREE.PointLight(controls.lightColor, controls.lightIntensity,
                                          controls.lightDistance, 2);
      light.position.set(0, 14.5, 0);
      //light.distance = controls.lightDistance;
      light.castShadow = true;
      light.shadow.mapSize.width = 1024;
      light.shadow.mapSize.height = 1024;
      scene.add(light);
      return light;      
    })();*/

    const ambientLight = (_ => {
      const light = new THREE.AmbientLight("#ffffff"); //#0c0c0c ffffff 606060
      scene.add(light);
      return light;
    })();

    // PointLight „ÅÆ„Éò„É´„Éë„Éº„ÇíËøΩÂä†
    //const lightHelper = new THREE.PointLightHelper(pointLight, 1);  // „Çµ„Ç§„Ç∫1„ÅÆ„Éò„É´„Éë„Éº
    //scene.add(lightHelper);


    const stats = (_ => {
      const stats = new Stats();
      stats.domElement.style.position = "absolute";
      stats.domElement.style.left = "0px";
      stats.domElement.style.top = "0px";
      //document.getElementById("stats").appendChild(stats.domElement);
      document.body.appendChild(stats.domElement);
      return stats;
    })();

    

    const camera = (_ => {
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 15, 30);
      camera.lookAt(0, 7.5, 0);
      return camera;
    })();





    // Three.js „ÅÆ OrbitControls „ÇíËøΩÂä†
    const CamControls = new OrbitControls(camera, renderer.domElement);
    CamControls.enableDamping = true; // ÊÖ£ÊÄß„ÇíÊúâÂäπ„Å´„Åô„Çã
    CamControls.dampingFactor = 0.05; // ÊÖ£ÊÄß„ÅÆÂº∑„Åï
    CamControls.screenSpacePanning = false; // „Éë„É≥Êìç‰Ωú„ÇíÁîªÈù¢Á©∫Èñì„ÅßË°å„ÅÜ
    CamControls.minDistance = 10; // ÊúÄÂ∞è„Ç∫„Éº„É†Ë∑ùÈõ¢
    CamControls.maxDistance = 100; // ÊúÄÂ§ß„Ç∫„Éº„É†Ë∑ùÈõ¢
    CamControls.maxPolarAngle = Math.PI / 2; // ÂûÇÁõ¥ÊñπÂêë„ÅÆÂõûËª¢Âà∂Èôê (Âú∞Èù¢„ÅÆ‰∏ã„ÇíË¶ã„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã)

    /*const floor = (_ => {
      const geo = new THREE.PlaneGeometry(20, 20);
      const mat = new THREE.MeshPhongMaterial({ shininess: 10, color: "#fff" });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = Math.PI * -.5;
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    })();*/

    const createCamouflageTexture = (dotcolor1, dotcolor2) => {
        const size = 512; // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÅÆËß£ÂÉèÂ∫¶
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
      
        // ËÉåÊôØ„ÇíÈªí„Å´Ë®≠ÂÆö
        ctx.fillStyle = '#252627';
        ctx.fillRect(0, 0, size, size);
      
        // „É©„É≥„ÉÄ„É†„Å™ÁôΩ„ÅÑÊñëÁÇπ„ÇíÊèèÁîª
        for (let i = 0; i < 200; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const r = Math.random() * 3 + 3; // „É©„É≥„ÉÄ„É†„Å™„Çµ„Ç§„Ç∫
          ctx.fillStyle = dotcolor1; //'white'; // white
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }

        // „É©„É≥„ÉÄ„É†ÊñëÁÇπ2„Å§ÁõÆ
        for (let i = 0; i < 200; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const r = Math.random() * 3 + 3; // „É©„É≥„ÉÄ„É†„Å™„Çµ„Ç§„Ç∫
            ctx.fillStyle = dotcolor2; //'white'; // white
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
          }
      
        return new THREE.CanvasTexture(canvas);
      };
      
      const floor = (_ => {
        const geo = new THREE.PlaneGeometry(20, 50);
        const texture = createCamouflageTexture('gray', 'white'); // Ëø∑ÂΩ©„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÁîüÊàê
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(10, 10); // „Çø„Ç§„É´Áä∂„Å´ÈÅ©Áî®
      
        const mat = new THREE.MeshPhongMaterial({
          shininess: 10,
          map: texture,
        });
      
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI * -.5;
        mesh.position.set(0, 0, -5); //z=00
        mesh.receiveShadow = true;
        scene.add(mesh);
      
        return mesh;
      })();
      

    const leftWall = (_ => {
      const geo = new THREE.PlaneGeometry(50, 15);
      const mat = new THREE.MeshPhongMaterial({ color: "#ffffe0" }); // #ff0000 Â£Å„ÅÆËâ≤„ÅØ#ffffe0
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.y = Math.PI * 0.5;
      mesh.position.set(-10, 7.5, -5); //z=00

      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    })();

    const rightWall = (_ => {
      const geo = new THREE.PlaneGeometry(50, 15);
      const mat = new THREE.MeshPhongMaterial({ color: "#ffffe0" }); // #00ff00
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.y = Math.PI * -0.5;
      mesh.position.set(10, 7.5, -5);
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    })();

    const backWall = (_ => {
      const geo = new THREE.PlaneGeometry(15, 20);
      const mat = new THREE.MeshPhongMaterial({ shininess: 1, color: "#ffffe0" }); // #fff
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.z = Math.PI * -0.5;
      mesh.position.set(0, 7.5, -30); //-10„Åã„ÇâÂ§âÊõ¥
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    })();

    /*const ceiling = (_ => {
      const geo = new THREE.PlaneGeometry(20, 20);
      const mat = new THREE.MeshPhongMaterial({ color: "#fff" });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = Math.PI * 0.5;
      mesh.position.set(0, 15, 0);
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    })();*/

    const createCeilingTexture = () => {
        const width = 1024, height = 512; // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Çµ„Ç§„Ç∫
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
    
        // ÁôΩ„ÅÑËÉåÊôØ
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);
    
        // Â∞è„Åï„Å™Èªí„ÅÑÊñëÁÇπ„ÇíÊèèÁîª
        for (let i = 0; i < 300; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const r = Math.random() * 2 + 1; // Â∞è„Åï„Å™ÊñëÁÇπ
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }
    
        // Ê®™„ÅÆÈªí„ÅÑÁ∑ö„Çí‰∏ÄÂÆöÈñìÈöî„ÅßÊèèÁîª
        const numLines = 13; // ‰ΩïÊú¨„ÅÆÁ∑ö„ÇíÂºï„Åè„Åã
        const lineSpacing = height / (numLines + 1); // ÂùáÁ≠â„Å™ÈñìÈöî
    
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1; // Á∑ö„ÇíÁ¥∞„Åè„Åô„Çã
    
        let rowPositions = []; // ÂêÑË°å„ÅÆYÂ∫ßÊ®ô„Çí‰øùÂ≠ò
    
        for (let i = 1; i <= numLines; i++) {
            const y = i * lineSpacing;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
            rowPositions.push(y);
        }
    
        // Á∏¶„ÅÆÈªí„ÅÑÁ∑ö„Çí row „Åî„Å®„Å´„É©„É≥„ÉÄ„É†„Å™ÈñìÈöî„ÅßÈÖçÁΩÆ
        // Á∏¶„ÅÆÈªí„ÅÑÁ∑ö„Çí row „Åî„Å®„Å´‰∫§‰∫í„Å´„É©„É≥„ÉÄ„É†„Å™ÈñìÈöî„ÅßÈÖçÁΩÆ
        ctx.lineWidth = 2; // Á∏¶Á∑ö„ÇÇÁ¥∞„Åè„Åô„Çã

        rowPositions.forEach((y, index) => {

            const spacing = index % 2 === 0
                ?  150 // ÂÅ∂Êï∞Ë°å
                : 140; // Â•áÊï∞Ë°å

            for (let x = spacing; x < width; x += spacing) { // ‰∏ÄÂÆö„ÅÆË∑ùÈõ¢„Åî„Å®„Å´Á∏¶Á∑ö„ÇíÊèèÁîª
                ctx.beginPath();
                ctx.moveTo(x, y); // Á∏¶Á∑ö„ÅÆÈñãÂßã‰ΩçÁΩÆ (Ê®™Á∑ö„ÅÆ‰ΩçÁΩÆ)
                ctx.lineTo(x, y + lineSpacing); // Ê¨°„ÅÆÊ®™Á∑ö„Åæ„ÅßÂºï„Åè
                ctx.stroke();
            }
        });

        return new THREE.CanvasTexture(canvas);
    };
    
    const createCeiling = () => {
        const geo = new THREE.PlaneGeometry(20, 50); // Â§©‰∫ï„ÅÆ„Çµ„Ç§„Ç∫ (Â§ß„Åç„Å™Âπ≥Èù¢)
        const texture = createCeilingTexture();
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
    
        const mat = new THREE.MeshBasicMaterial({
            map: texture,
            shininess: 10,
        });
    
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI * 0.5;
        mesh.position.set(0, 15, -5);
        mesh.receiveShadow = true;
        scene.add(mesh);
    
        return mesh;
    };
    
    const ceiling = createCeiling();
    

    const createTable = (x, y, z, width, depth, legX, legZ) => {
      const tableGroup = new THREE.Group();
      const tableMaterial = new THREE.MeshPhongMaterial({ color: "#FFFFFF" }); // ÁôΩËâ≤
  
      // **üü¶ Â§©ÊùøÔºàTabletopÔºâ**
      const tabletopGeometry = new THREE.BoxGeometry(width, 0.1, depth);
      const tabletop = new THREE.Mesh(tabletopGeometry, tableMaterial);
      tabletop.position.set(0, 3, 0);
      tableGroup.add(tabletop);
  
      // **üü† ËÑöÔºàCylindrical LegsÔºâ**
      const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 32);
      
      // Â∑¶ËÑö
      const leftLeg = new THREE.Mesh(legGeometry, tableMaterial);
      leftLeg.position.set(legX, 1.5, legZ);
      tableGroup.add(leftLeg);
  
      // Âè≥ËÑö
      const rightLeg = new THREE.Mesh(legGeometry, tableMaterial);
      rightLeg.position.set(-legX, 1.5, -legZ);
      tableGroup.add(rightLeg);
  
      // üåç **„ÉÜ„Éº„Éñ„É´ÂÖ®‰Ωì„ÇíÊåáÂÆö‰ΩçÁΩÆ„Å´ÁßªÂãï**
      tableGroup.position.set(x, y, z);
  
      scene.add(tableGroup);
      return tableGroup;
  };
  
  // ‚úÖ **„Éï„É≠„É≥„Éà„ÉÜ„Éº„Éñ„É´ÈÖçÁΩÆ**
  const Front_table = [
      { x: -3, y: 0, z: -20 },
      { x: 3, y: 0, z: -20 }
  ];
  
  // ‚úÖ **Â∑¶„Çµ„Ç§„Éâ„ÉÜ„Éº„Éñ„É´ÈÖçÁΩÆ**
  const SL_table = [
      { x: -4.5, y: 0, z: -15 },
      { x: -4.5, y: 0, z: -9 },
      { x: -4.5, y: 0, z: -3 }
  ];
  
  // ‚úÖ **Âè≥„Çµ„Ç§„Éâ„ÉÜ„Éº„Éñ„É´ÈÖçÁΩÆ**
  const SR_table = [
      { x: 4.5, y: 0, z: -15 },
      { x: 4.5, y: 0, z: -9 },
      { x: 4.5, y: 0, z: -3 }
  ];
  
  // **„ÉÜ„Éº„Éñ„É´„Çí„É´„Éº„Éó„ÅßÈÖçÁΩÆ**
  Front_table.forEach(pos => createTable(pos.x, pos.y, pos.z, 6, 3, 2.5, 0)); // „Éï„É≠„É≥„Éà„ÉÜ„Éº„Éñ„É´
  SL_table.forEach(pos => createTable(pos.x, pos.y, pos.z, 3, 6, 0, 2.5));  // Â∑¶„Çµ„Ç§„Éâ„ÉÜ„Éº„Éñ„É´
  SR_table.forEach(pos => createTable(pos.x, pos.y, pos.z, 3, 6, 0, 2.5));  // Âè≥„Çµ„Ç§„Éâ„ÉÜ„Éº„Éñ„É´
  
  
  const table_height = 3;
  const Ftable_zpos = -20;
  const cone_height = 1.5;
  const cylinder_height = 1.5;
  const spher_rad = 0.5;
  //const spher_height = 2*Math.pi*spher_rad;

    // **üìå ÂÜÜÈåêÔºàConeÔºâ**
  const coneGeometry = new THREE.ConeGeometry(0.5, 1.5, 32);
  const coneMaterial = new THREE.MeshLambertMaterial({ color: "#FF5733" }); // Êòé„Çã„ÅÑ„Ç™„É¨„É≥„Ç∏
  const cone = new THREE.Mesh(coneGeometry, coneMaterial);
  cone.position.set(-3, table_height + (cone_height/2), Ftable_zpos);
  scene.add(cone);

  // **üìå ÂÜÜÊü±ÔºàCylinderÔºâ**
  
  const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32);
  const cylinderMaterial = new THREE.MeshPhongMaterial({ color: "#33A8FF", shininess: 100 }); // Èùí„Åø„ÅÆ„ÅÇ„ÇãÂÖâÊ≤¢
  const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
  cylinder.position.set(3, table_height +(cylinder_height/2), Ftable_zpos);
  scene.add(cylinder);

  // **üìå ÁêÉ‰ΩìÔºàSphereÔºâ**
  const sphereGeometry = new THREE.SphereGeometry(spher_rad, 32, 32);
  const sphereMaterial = new THREE.MeshPhysicalMaterial({
      color: "#FFD700", // „Ç¥„Éº„É´„Éâ
      roughness: 0.2,
      metalness: 0.8
  });
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  sphere.position.set(0, table_height+spher_rad, Ftable_zpos);
  scene.add(sphere);
    
    






    {
      //Ëª∏„ÇíËøΩÂä†„Åô„Çã„ÄÇ
      const axesHelper = new THREE.AxesHelper(70); // Ëª∏„ÅÆÈï∑„Åï
      // XËª∏:Ëµ§ YËª∏:Á∑ë ZËª∏:Èùí
      scene.add(axesHelper);

      // XËª∏ÂÖ®‰Ωì„ÇíËµ§„Å´Ë®≠ÂÆö
      axesHelper.geometry.attributes.color.array.set([1, 0, 0], 0); // ÂßãÁÇπ (R, G, B)
      axesHelper.geometry.attributes.color.array.set([1, 0, 0], 3); // ÁµÇÁÇπ (R, G, B)

      // YËª∏ÂÖ®‰Ωì„ÇíÁ∑ë„Å´Ë®≠ÂÆö
      axesHelper.geometry.attributes.color.array.set([0, 1, 0], 6); // ÂßãÁÇπ (R, G, B)
      axesHelper.geometry.attributes.color.array.set([0, 1, 0], 9); // ÁµÇÁÇπ (R, G, B)

      // ZËª∏ÂÖ®‰Ωì„ÇíÈùí„Å´Ë®≠ÂÆö
      axesHelper.geometry.attributes.color.array.set([0, 0, 1], 12); // ÂßãÁÇπ (R, G, B)
      axesHelper.geometry.attributes.color.array.set([0, 0, 1], 15); // ÁµÇÁÇπ (R, G, B)
      // Ëâ≤„ÅÆÂ§âÊõ¥„ÇíÊúâÂäπÂåñ
      axesHelper.geometry.attributes.color.needsUpdate = true;
  }


    document.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft"){
        left = 1;
        e.preventDefault();
      }
      if (e.key === "ArrowRight"){
        right = 1;
        e.preventDefault();
      }
      if (e.key === "ArrowUp"){
        up = 1;
        e.preventDefault();
      }
      if (e.key === "ArrowDown"){
        down = 1;
        e.preventDefault();
      }
    });
    document.addEventListener("keyup", e => {
      if (e.key === "ArrowLeft"){
        left = 0;
        e.preventDefault();
      }
      if (e.key === "ArrowRight"){
        right = 0;
        e.preventDefault();
      }
      if (e.key === "ArrowUp"){
        up = 0;
        e.preventDefault();
      }
      if (e.key === "ArrowDown"){
        down = 0;
        e.preventDefault();
      }
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    

    function animate(){
      requestAnimationFrame(animate);

      if (left && sphere.position.x > -7){
        sphere.position.x -= 0.1;
        sphere.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), 0.05);
      }
      if (right && sphere.position.x < 7){
        sphere.position.x += 0.1;
        sphere.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), -0.05);
      }
      if (up && sphere.position.z > -7){
        sphere.position.z -= 0.1;
        sphere.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), -0.05);
      }
      if (down && sphere.position.z < 7){
        sphere.position.z += 0.1;
        sphere.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), 0.05);
      }

      //pointLight.intensity = controls.lightIntensity;
      //pointLight.distance = controls.lightDistance;

      //createRectLight.intensity = controls.lightIntensity;
      //createRectLight.distance = controls.lightDistance;


      //const b = Math.round(255 * controls.lightIntensity);
      //sphere.children[0].material.color = new THREE.Color(`rgb(${b}, ${b}, ${b})`);

      /*let newLightColor = {};
      Object.keys(lightPanel.material.color).forEach(channel => {
        newLightColor[channel] = new THREE.Color(controls.lightColor)[channel] * controls.lightIntensity;
      });
      lightPanel.material.color = newLightColor;
      */
      
/*
      let new_createRectLight = {};
      Object.keys(createRectLight.material.color).forEach(channel => {
        new_createRectLight[channel] = new THREE.Color(controls.lightColor)[channel] * controls.lightIntensity;
      });
      createRectLight.material.color = new_createLightPanelSet;*/

      stats.update();
      CamControls.update();
      renderer.render(scene, camera);
    }
    animate();

    function size(){
      //camera.aspect = window.innerWidth / window.innerHeight;
      //renderer.setSize(window.innerWidth, window.innerHeight);

      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    size();
    onresize = size;  
  </script>
</body>
</html>