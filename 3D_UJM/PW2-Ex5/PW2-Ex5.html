<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
  />
<title>PRACTICAL WORK 2 - Ex5</title>
  <style>
    html,
    body {
        height: 100%;
        width: 100%;
        margin: 0;
        overflow: hidden;
    }

    #c {
        width: 100%;
        height: 100%;
        display: block;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  </body>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/",
        "three/src/math/MathUtils": "https://unpkg.com/three@0.172.0/src/math/MathUtils.js"
        }
    }
</script>

  <script type="module">
    
    // https://gist.github.com/HarryStevens/606a8e6cec5de7dd72e933c0b1b793db
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import Stats from 'three/addons/libs/stats.module.js';
    import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
    import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';



  const scene = new THREE.Scene();
  
  const canvas = document.querySelector( '#c' );

  const renderer = (_ => {
    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor("#000");
    renderer.setPixelRatio(devicePixelRatio);
    renderer.outputEncoding = THREE.sRGBEncoding;

    renderer.gammaOutput = true;
    renderer.gammaFactor = 2.2;

    return renderer;
  })();


  const LightFolderParams ={
    type: "PointLight",
    intensity: 30,
    distance: 30,
    color: "#fff",
    angle: Math.PI / 4, // SpotLight ç”¨
    penumbra: 0.5 // SpotLight ç”¨
  }
  const WallFolderParams ={
    color:  "#ffffe0" 
  }

  const textureLoader = new THREE.TextureLoader();

  const urls = [
  "right.png","left.png",
  "up.png","down.png",
  "front.png","back.png"
  ]

  const materialParams = {
    color: "#ffffff",
    transparency: 1.0,
    shininess: 30,
    roughness: 0.5,
    metalness: 0.5,
    emissiveIntensity: 1,
    specularMap: null,
    map: null,
    envMap: null

  }

  let currentLight = []; // ç¾åœ¨ã®ãƒ©ã‚¤ãƒˆã‚’ç®¡ç†


    
  const gui = (_ => {
    const gui = new GUI();
    const LightFolder = gui.addFolder('Light');
    //const WallFolder = gui.addFolder('Wall');
    const materialFolder = gui.addFolder('Material');


    // ğŸ”¹ ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’é¸æŠ
    LightFolder.add(LightFolderParams, 'type', ['PointLight', 'DirectionalLight', 'SpotLight', 'HemisphereLight']).onChange(value => {
      switchLights(value);
    });


    LightFolder.add(LightFolderParams, 'intensity', 0, 100).onChange(value => {
      currentLight.forEach(light => light.intensity = value);
    });
    /*
    LightFolder.add(LightFolderParams, "distance", 0, 100).onChange(value => {
      currentLight.forEach(light => light.distance = value);
    });*/
    LightFolder.addColor(LightFolderParams, "color").onChange(e => {
      currentLight.forEach(light => light.color.set(e));
    });

    /*WallFolder.addColor(WallFolderParams, "color").name("Left Wall Color").onChange(value => {
      leftWall.material.color.set(value);
    });*/

    // è‰²å¤‰æ›´
    materialFolder.addColor(materialParams, "color").onChange(value => {
      coneMaterial.color.set(value);
      cylinderMaterial.color.set(value);
      sphereMaterial.color.set(value);
    });

    // é€æ˜åº¦
    materialFolder.add(materialParams, "transparency", 0, 1).onChange(value => {
      coneMaterial.opacity = value;
      cylinderMaterial.opacity = value;
      sphereMaterial.opacity = value;
    });

    // å…‰æ²¢ï¼ˆPhongMaterial ã®ã¿é©ç”¨ï¼‰
    materialFolder.add(materialParams, "shininess", 0, 100).onChange(value => {
      cylinderMaterial.shininess = value;
    });

    // ãƒ©ãƒ•ãƒã‚¹ï¼ˆPhysicalMaterial ã®ã¿é©ç”¨ï¼‰
    materialFolder.add(materialParams, "roughness", 0, 1).onChange(value => {
      sphereMaterial.roughness = value;
    });

    // ãƒ¡ã‚¿ãƒ«ãƒã‚¹ï¼ˆPhysicalMaterial ã®ã¿é©ç”¨ï¼‰
    materialFolder.add(materialParams, "metalness", 0, 1).onChange(value => {
      sphereMaterial.metalness = value;
    });

    // ãƒ¡ã‚¿ãƒ«ãƒã‚¹ï¼ˆPhysicalMaterial ã®ã¿é©ç”¨ï¼‰
    materialFolder.add(materialParams, "emissiveIntensity", 0, 1).onChange(value => {
      coneMaterial.emissiveIntensity = value;
    });

   // GUI ã« `map` ã®é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¿½åŠ 
    materialFolder.add(materialParams, "map", ["None", "wood.jpg"]).onChange(value => {
      if (value === "None") {
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãªã—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
        coneMaterial.map = null;
        cylinderMaterial.map = null;
        sphereMaterial.map = null;
      } else {
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ­ãƒ¼ãƒ‰
        const tex = textureLoader.load(value);
        coneMaterial.map = tex;
        cylinderMaterial.map = tex;
        sphereMaterial.map = tex;
      }

      // ãƒ†ã‚¯ã‚¹ãƒãƒ£æ›´æ–°ã‚’é©ç”¨
      coneMaterial.needsUpdate = true;
      cylinderMaterial.needsUpdate = true;
      sphereMaterial.needsUpdate = true;
    });

    
    // GUI ã« `envMap` ã®é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¿½åŠ 
    materialFolder.add(materialParams, "envMap", ["None", "nature"]).onChange(value => {
      if (value === "None") {
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãªã—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
        coneMaterial.envMap = null;
        cylinderMaterial.envMap = null;
        sphereMaterial.envMap = null;
      } else {
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ­ãƒ¼ãƒ‰
        const envloader = new THREE.CubeTextureLoader();
        const textureCube = envloader.load(urls);
        textureCube.mapping = THREE.CubeReflectionMapping; //åå°„ãƒãƒƒãƒ”ãƒ³ã‚°ã®è¨­å®š

        coneMaterial.envMap = textureCube;
        cylinderMaterial.envMap = textureCube;
        sphereMaterial.envMap = textureCube;
      }

      // ãƒ†ã‚¯ã‚¹ãƒãƒ£æ›´æ–°ã‚’é©ç”¨
      coneMaterial.needsUpdate = true;
      cylinderMaterial.needsUpdate = true;
      sphereMaterial.needsUpdate = true;
    });

    // GUI ã« `specularMap` ã®é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¿½åŠ 
    materialFolder.add(materialParams, "specularMap", ["None", "roughness"]).onChange(value => {
      if (value === "None") {
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãªã—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
        coneMaterial.specularMap = null;
        cylinderMaterial.specularMap = null;
        //sphereMaterial.specularMap = null;
      } else {
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ­ãƒ¼ãƒ‰
        const specularTexture = new THREE.TextureLoader().load('dec.jpg')

        coneMaterial.specularMap = specularTexture;
        cylinderMaterial.specularMap = specularTexture;
        //sphereMaterial.specularMap = specularTexture;
      }

      // ãƒ†ã‚¯ã‚¹ãƒãƒ£æ›´æ–°ã‚’é©ç”¨
      coneMaterial.needsUpdate = true;
      cylinderMaterial.needsUpdate = true;
      sphereMaterial.needsUpdate = true;
    });


    return gui;
  })();


  // 3ã¤ã®ãƒ©ã‚¤ãƒˆãƒ‘ãƒãƒ«ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆä½ç½®
  const panelOffsets = [
      { x: -5, z: -25 }, { x: 0, z: -25 }, { x: 5, z: -25 },
      { x: -5, z: -19 }, { x: 0, z: -19 }, { x: 5, z: -19 },
      { x: -5, z: -10 }, { x: 0, z: -10 }, { x: 5, z: -10 },
      { x: -5, z: -4 }, { x: 0, z: -4 }, { x: 5, z: -4 }
  ];    


  let covers = []; // ğŸ”¹ ã™ã¹ã¦ã®ãƒ‘ãƒãƒ«ã‚’æ ¼ç´ã™ã‚‹ãƒªã‚¹ãƒˆ

    // ğŸ”¹ æ—¢å­˜ã®ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤ã—ã€æ–°ã—ã„ãƒ©ã‚¤ãƒˆã‚’ä½œæˆ
  function switchLights(type) {
    // æ—¢å­˜ã®ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
    currentLight.forEach(light => {
      scene.remove(light)
      if (light.dispose) light.dispose(); // ãƒ¡ãƒ¢ãƒªè§£æ”¾

      // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤
      if (light.helper) {
        scene.remove(light.helper);
        if (light.helper.dispose) light.helper.dispose(); // ãƒ˜ãƒ«ãƒ‘ãƒ¼ã®ãƒ¡ãƒ¢ãƒªè§£æ”¾
      }
    });
    currentLight = []; // reset lights

    // ğŸ”¹ `covers` ã‚’åˆ©ç”¨ã—ã¦æ­£ã—ããƒ©ã‚¤ãƒˆã‚’ä½œæˆ
    covers.forEach(cover => {
        const newLight = createLight(cover, scene); // âœ… `cover` ã‚’æ­£ã—ãæ¸¡ã™
        currentLight.push(newLight);
    });
  }


  // ğŸ”¹ ãƒ‘ãƒãƒ«ã®ä½œæˆã‚’ `createLightPanelSet()` ã«ä»»ã›ã‚‹
  const createLightPanelSet = (panelOffsets, scene) => {
    const setGroup = new THREE.Group();
    const coverMat = new THREE.MeshPhongMaterial({ color: LightFolderParams.color });

    covers = []; // ğŸ”¹ æ—¢å­˜ã® `covers` ã‚’ãƒªã‚»ãƒƒãƒˆ

    panelOffsets.forEach(offset => {
        const coverGeo = new THREE.BoxGeometry(4, 0.2, 1);
        const cover = new THREE.Mesh(coverGeo, coverMat);
        cover.position.set(offset.x, 12, offset.z);
        setGroup.add(cover);
        covers.push(cover); // ğŸ”¹ `covers` é…åˆ—ã«è¿½åŠ 
    });

    scene.add(setGroup);
    return setGroup;
  };

  const createLight = (cover, scene) =>{

    let light;
    let lightHelper = null;

    switch (LightFolderParams.type) {
      case 'PointLight':
          light = new THREE.PointLight(LightFolderParams.color, LightFolderParams.intensity, LightFolderParams.distance);
          lightHelper = new THREE.PointLightHelper(light, 1); // ğŸ”¹ PointLightç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
          break;
      case 'DirectionalLight':
          light = new THREE.DirectionalLight(LightFolderParams.color, LightFolderParams.intensity);
          lightHelper = new THREE.DirectionalLightHelper(light, 2); // ğŸ”¹ DirectionalLightç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
          break;
      case 'SpotLight':
          light = new THREE.SpotLight(LightFolderParams.color, LightFolderParams.intensity);
          light.angle = Math.PI/3;
          light.penumbra = 0;
          light.decay = 2;


          // ğŸ”¹ **å…‰ã®ä½ç½®ã‚’ãƒ‘ãƒãƒ«ã®ä¸Šã«é…ç½®**
          light.position.set(cover.position.x, cover.position.y, cover.position.z);

          // ğŸ”¹ **ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ãƒ‘ãƒãƒ«ã®ä½ç½®ã«è¨­å®š**
          const target = new THREE.Object3D();
          target.position.set(cover.position.x, 0, cover.position.z);
          scene.add(target);
          light.target = target;

          lightHelper = new THREE.SpotLightHelper(light); // ğŸ”¹ SpotLightç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
          break;
      case 'HemisphereLight':
          light = new THREE.HemisphereLight(LightFolderParams.color, 0x444444, LightFolderParams.intensity);
          lightHelper = new THREE.HemisphereLightHelper(light, 2); // ğŸ”¹ HemisphereLightç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
          break;
  }
      
      
    // ä½ç½®è¨­å®š
    light.position.copy(cover.position);
    light.position.y += -0.5; // **å°‘ã—ä¸Šã«é…ç½®**

    // ğŸ”¹ ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’è¿½åŠ ï¼ˆlightHelperãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ï¼‰
    if (lightHelper) {
      scene.add(lightHelper);
      light.helper = lightHelper; // ğŸ”¹ ãƒ©ã‚¤ãƒˆã«ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’é–¢é€£ä»˜ã‘ã‚‹ï¼ˆå‰Šé™¤æ™‚ã«å‚ç…§ã™ã‚‹ãŸã‚ï¼‰
    }

    // **ãƒ©ã‚¤ãƒˆã‚’ã‚·ãƒ¼ãƒ³ã«è¿½åŠ **
    scene.add(light);

    light.castShadow = true;
    // ğŸ”¹ shadow ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ mapSize ã‚’è¨­å®š
    if (light.castShadow && light.shadow) {
      light.shadow.mapSize.width = 512;
      light.shadow.mapSize.height = 512;
    }

    return light;
  };

  
  const lightPanelSets = createLightPanelSet(panelOffsets, scene);
  switchLights('PointLight'); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ PointLight ã‚’ã‚»ãƒƒãƒˆ


/*
    const ambientLight = (_ => {
      const light = new THREE.AmbientLight("#ffffff"); //#0c0c0c ffffff 606060
      scene.add(light);
      return light;
    })();*/


    // å£ã«å¯¾å¿œã—ãŸé•·æ–¹å½¢ãƒ©ã‚¤ãƒˆã‚’ä½œæˆã™ã‚‹é–¢æ•°
    function createWallLight(color, position, width, height, rotation) {
        //const intensity = 5;
    
        const rectLight = new THREE.RectAreaLight(color, 0.5, width, height);
        rectLight.position.set(position.x, 7.5, position.z); //LightFolderParams.intensity 7.5
        rectLight.rotation.set(rotation.x, rotation.y, rotation.z);
    
        scene.add(rectLight);
    
        // ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’è¿½åŠ ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
        //const rectLightHelper = new RectAreaLightHelper(rectLight);
        //rectLight.add(rectLightHelper);
    
        return rectLight;
    }
    
    // ğŸ”¹ å·¦ã®å£ã®å…‰ï¼ˆå£ã®è‰²ã‚’åæ˜ ï¼‰
    createWallLight('#ffffe0', { x: -9.9, z: -5 }, 50, 15, { x: 0, y: -Math.PI / 2, z: 0});
    //createWallLight('#ffffe0', { x: -8, z: -15 }, 20, 7, { x: 0, y: Math.PI / 2, z: 0});
    
    // ğŸ”¹ å³ã®å£ã®å…‰
    createWallLight('#ffffe0', { x: 9.9, z: -5 }, 50, 15, { x: 0, y: Math.PI / 2, z: 0});
    
    // ğŸ”¹ èƒŒé¢ã®å£ã®å…‰
    createWallLight('#ffffe0', { x: 0, z: -29.9 }, 15, 20, { x: Math.PI, y: 0, z: Math.PI * -0.5});


    



    const stats = (_ => {
      const stats = new Stats();
      stats.domElement.style.position = "absolute";
      stats.domElement.style.left = "0px";
      stats.domElement.style.top = "0px";
      //document.getElementById("stats").appendChild(stats.domElement);
      document.body.appendChild(stats.domElement);
      return stats;
    })();

    

    const camera = (_ => {
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 15, 30);
      camera.lookAt(0, 7.5, 0);
      return camera;
    })();





    // Three.js ã® OrbitControls ã‚’è¿½åŠ 
    const CamControls = new OrbitControls(camera, renderer.domElement);
    CamControls.enableDamping = true; // æ…£æ€§ã‚’æœ‰åŠ¹ã«ã™ã‚‹
    CamControls.dampingFactor = 0.05; // æ…£æ€§ã®å¼·ã•
    CamControls.screenSpacePanning = false; // ãƒ‘ãƒ³æ“ä½œã‚’ç”»é¢ç©ºé–“ã§è¡Œã†
    CamControls.minDistance = 10; // æœ€å°ã‚ºãƒ¼ãƒ è·é›¢
    CamControls.maxDistance = 100; // æœ€å¤§ã‚ºãƒ¼ãƒ è·é›¢
    CamControls.maxPolarAngle = Math.PI / 2; // å‚ç›´æ–¹å‘ã®å›è»¢åˆ¶é™ (åœ°é¢ã®ä¸‹ã‚’è¦‹ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹)

    /*const floor = (_ => {
      const geo = new THREE.PlaneGeometry(20, 20);
      const mat = new THREE.MeshPhongMaterial({ shininess: 10, color: "#fff" });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = Math.PI * -.5;
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    })();*/

    const createCamouflageTexture = (dotcolor1, dotcolor2) => {
        const size = 512; // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è§£åƒåº¦
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
      
        // èƒŒæ™¯ã‚’é»’ã«è¨­å®š
        ctx.fillStyle = '#252627';
        ctx.fillRect(0, 0, size, size);
      
        // ãƒ©ãƒ³ãƒ€ãƒ ãªç™½ã„æ–‘ç‚¹ã‚’æç”»
        for (let i = 0; i < 200; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const r = Math.random() * 3 + 3; // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚µã‚¤ã‚º
          ctx.fillStyle = dotcolor1; //'white'; // white
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }

        // ãƒ©ãƒ³ãƒ€ãƒ æ–‘ç‚¹2ã¤ç›®
        for (let i = 0; i < 200; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const r = Math.random() * 3 + 3; // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚µã‚¤ã‚º
            ctx.fillStyle = dotcolor2; //'white'; // white
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
          }
      
        return new THREE.CanvasTexture(canvas);
      };
      
      const floor = (_ => {
        const geo = new THREE.PlaneGeometry(20, 50);
        const texture = createCamouflageTexture('gray', 'white'); // è¿·å½©ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(10, 10); // ã‚¿ã‚¤ãƒ«çŠ¶ã«é©ç”¨
      
        const mat = new THREE.MeshPhongMaterial({
          shininess: 10,
          map: texture,
        });
      
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI * -.5;
        mesh.position.set(0, 0, -5); //z=00
        mesh.receiveShadow = true;
        scene.add(mesh);
      
        return mesh;
      })();
      

    const leftWall = (_ => {
      const geo = new THREE.PlaneGeometry(50, 15);
      const mat = new THREE.MeshPhongMaterial({ color: WallFolderParams.color }); // #ff0000 å£ã®è‰²ã¯#ffffe0
      const leftWall = new THREE.Mesh(geo, mat);
      leftWall.rotation.y = Math.PI * 0.5;
      leftWall.position.set(-10, 7.5, -5); //z=00

      leftWall.receiveShadow = true;
      scene.add(leftWall);
      return leftWall;
    })();

    const rightWall = (_ => {
      const geo = new THREE.PlaneGeometry(50, 15);
      const mat = new THREE.MeshPhongMaterial({ color: "#ffffe0" }); // #00ff00
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.y = Math.PI * -0.5;
      mesh.position.set(10, 7.5, -5);
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    })();

    const backWall = (_ => {
      const geo = new THREE.PlaneGeometry(15, 20);
      const mat = new THREE.MeshPhongMaterial({color: "#ffffe0" }); // #fff
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.z = Math.PI * -0.5;
      mesh.position.set(0, 7.5, -30); //-10ã‹ã‚‰å¤‰æ›´
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    })();


    const createCeilingTexture = () => {
        const width = 1024, height = 512; // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚º
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
    
        // ç™½ã„èƒŒæ™¯
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);
    
        // å°ã•ãªé»’ã„æ–‘ç‚¹ã‚’æç”»
        for (let i = 0; i < 300; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const r = Math.random() * 2 + 1; // å°ã•ãªæ–‘ç‚¹
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }
    
        // æ¨ªã®é»’ã„ç·šã‚’ä¸€å®šé–“éš”ã§æç”»
        const numLines = 13; // ä½•æœ¬ã®ç·šã‚’å¼•ãã‹
        const lineSpacing = height / (numLines + 1); // å‡ç­‰ãªé–“éš”
    
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1; // ç·šã‚’ç´°ãã™ã‚‹
    
        let rowPositions = []; // å„è¡Œã®Yåº§æ¨™ã‚’ä¿å­˜
    
        for (let i = 1; i <= numLines; i++) {
            const y = i * lineSpacing;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
            rowPositions.push(y);
        }
    
        // ç¸¦ã®é»’ã„ç·šã‚’ row ã”ã¨ã«ãƒ©ãƒ³ãƒ€ãƒ ãªé–“éš”ã§é…ç½®
        // ç¸¦ã®é»’ã„ç·šã‚’ row ã”ã¨ã«äº¤äº’ã«ãƒ©ãƒ³ãƒ€ãƒ ãªé–“éš”ã§é…ç½®
        ctx.lineWidth = 2; // ç¸¦ç·šã‚‚ç´°ãã™ã‚‹

        rowPositions.forEach((y, index) => {

            const spacing = index % 2 === 0
                ?  150 // å¶æ•°è¡Œ
                : 140; // å¥‡æ•°è¡Œ

            for (let x = spacing; x < width; x += spacing) { // ä¸€å®šã®è·é›¢ã”ã¨ã«ç¸¦ç·šã‚’æç”»
                ctx.beginPath();
                ctx.moveTo(x, y); // ç¸¦ç·šã®é–‹å§‹ä½ç½® (æ¨ªç·šã®ä½ç½®)
                ctx.lineTo(x, y + lineSpacing); // æ¬¡ã®æ¨ªç·šã¾ã§å¼•ã
                ctx.stroke();
            }
        });

        return new THREE.CanvasTexture(canvas);
    };
    
    const createCeiling = () => {
        const geo = new THREE.PlaneGeometry(20, 50); // å¤©äº•ã®ã‚µã‚¤ã‚º (å¤§ããªå¹³é¢)
        const texture = createCeilingTexture();
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
    
        const mat = new THREE.MeshPhongMaterial({
            map: texture,
            //shininess: 10,
        });
    
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI * 0.5;
        mesh.position.set(0, 15, -5);
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        scene.add(mesh);
    
        return mesh;
    };
    
    const ceiling = createCeiling();
    

    const createTable = (x, y, z, width, depth, legX, legZ) => {
      const tableGroup = new THREE.Group();
      const tableMaterial = new THREE.MeshPhongMaterial({ color: "#FFFFFF" }); // ç™½è‰²
  
      // **ğŸŸ¦ å¤©æ¿ï¼ˆTabletopï¼‰**
      const tabletopGeometry = new THREE.BoxGeometry(width, 0.1, depth);
      const tabletop = new THREE.Mesh(tabletopGeometry, tableMaterial);
      tabletop.position.set(0, 3, 0);
      // ğŸŒŸ å½±ã®è¨­å®šã‚’é©ç”¨
      tabletop.castShadow = true;    // ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å½±ã‚’è½ã¨ã™
      tabletop.receiveShadow = true; // ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å½±ã‚’å—ã‘ã‚‹
      tableGroup.add(tabletop);
  
      // **ğŸŸ  è„šï¼ˆCylindrical Legsï¼‰**
      const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 32);
      
      // å·¦è„š
      const leftLeg = new THREE.Mesh(legGeometry, tableMaterial);
      leftLeg.position.set(legX, 1.5, legZ);
      leftLeg.castShadow = true;    // ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å½±ã‚’è½ã¨ã™
      leftLeg.receiveShadow = true; // ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å½±ã‚’å—ã‘ã‚‹
      tableGroup.add(leftLeg);
  
      // å³è„š
      const rightLeg = new THREE.Mesh(legGeometry, tableMaterial);
      rightLeg.position.set(-legX, 1.5, -legZ);
      rightLeg.castShadow = true;    // ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å½±ã‚’è½ã¨ã™
      rightLeg.receiveShadow = true; // ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å½±ã‚’å—ã‘ã‚‹
      tableGroup.add(rightLeg);
  
      // ğŸŒ **ãƒ†ãƒ¼ãƒ–ãƒ«å…¨ä½“ã‚’æŒ‡å®šä½ç½®ã«ç§»å‹•**
      tableGroup.position.set(x, y, z);
  
      scene.add(tableGroup);
      return tableGroup;
  };
  
  // âœ… **ãƒ•ãƒ­ãƒ³ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«é…ç½®**
  const Front_table = [
      { x: -3, y: 0, z: -20 },
      { x: 3, y: 0, z: -20 }
  ];
  
  // âœ… **å·¦ã‚µã‚¤ãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«é…ç½®**
  const SL_table = [
      { x: -4.5, y: 0, z: -15 },
      { x: -4.5, y: 0, z: -9 },
      { x: -4.5, y: 0, z: -3 }
  ];
  
  // âœ… **å³ã‚µã‚¤ãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«é…ç½®**
  const SR_table = [
      { x: 4.5, y: 0, z: -15 },
      { x: 4.5, y: 0, z: -9 },
      { x: 4.5, y: 0, z: -3 }
  ];
  
  // **ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ãƒ«ãƒ¼ãƒ—ã§é…ç½®**
  Front_table.forEach(pos => createTable(pos.x, pos.y, pos.z, 6, 3, 2.5, 0)); // ãƒ•ãƒ­ãƒ³ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«
  SL_table.forEach(pos => createTable(pos.x, pos.y, pos.z, 3, 6, 0, 2.5));  // å·¦ã‚µã‚¤ãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«
  SR_table.forEach(pos => createTable(pos.x, pos.y, pos.z, 3, 6, 0, 2.5));  // å³ã‚µã‚¤ãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«
  



  
  const table_height = 3;
  const Ftable_zpos = -20;
  const cone_height = 1.5;
  const cylinder_height = 1.5;
  const spher_rad = 0.5;
  //const spher_height = 2*Math.pi*spher_rad;

  let texture;
  if (materialParams.map) {
    texture = textureLoader.load(materialParams.map);
  } else {
    texture = null;
  }


  // **ğŸ“Œ å††éŒï¼ˆConeï¼‰**
  const coneGeometry = new THREE.ConeGeometry(0.5, 1.5, 32);
  const coneMaterial = new THREE.MeshLambertMaterial({ 
    color: materialParams.color,
    transparent: true, 
    opacity:  materialParams.transparency,
    emissive: '#ed1212',
    emissiveIntensity: materialParams.emissiveIntensity,
    map: materialParams.map,
    envMap: materialParams.envMap,
    specularMap: materialParams.specularMap
  });
  const cone = new THREE.Mesh(coneGeometry, coneMaterial);
  cone.position.set(-3, table_height + (cone_height/2), Ftable_zpos);
  scene.add(cone);

  // **ğŸ“Œ å††æŸ±ï¼ˆCylinderï¼‰**
  
  const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32);
  const cylinderMaterial = new THREE.MeshPhongMaterial({
    color: materialParams.color, 
    specular: 0xffffff, // ğŸ”¥ åå°„ã‚’ç™½ãã—ã¦å¼·èª¿
    shininess: materialParams.shininess,
    transparent: true,
    opacity: materialParams.transparency,
    map: materialParams.map,
    envMap: materialParams.envMap,
    specularMap: materialParams.specularMap
  });
  const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
  cylinder.position.set(3, table_height +(cylinder_height/2), Ftable_zpos);
  scene.add(cylinder);

  // **ğŸ“Œ çƒä½“ï¼ˆSphereï¼‰**
  const sphereGeometry = new THREE.SphereGeometry(spher_rad, 32, 32);
  const sphereMaterial = new THREE.MeshPhysicalMaterial({
    color: materialParams.color,
    roughness: materialParams.roughness,
    metalness: materialParams.metalness,
    transparent: true,
    opacity: materialParams.transparency,
    map: materialParams.map,
    envMap: materialParams.envMap,
  });
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  sphere.position.set(0, table_height+spher_rad, Ftable_zpos);
  scene.add(sphere);
  
  
    



    {
      //è»¸ã‚’è¿½åŠ ã™ã‚‹ã€‚
      const axesHelper = new THREE.AxesHelper(70); // è»¸ã®é•·ã•
      // Xè»¸:èµ¤ Yè»¸:ç·‘ Zè»¸:é’
      scene.add(axesHelper);

      // Xè»¸å…¨ä½“ã‚’èµ¤ã«è¨­å®š
      axesHelper.geometry.attributes.color.array.set([1, 0, 0], 0); // å§‹ç‚¹ (R, G, B)
      axesHelper.geometry.attributes.color.array.set([1, 0, 0], 3); // çµ‚ç‚¹ (R, G, B)

      // Yè»¸å…¨ä½“ã‚’ç·‘ã«è¨­å®š
      axesHelper.geometry.attributes.color.array.set([0, 1, 0], 6); // å§‹ç‚¹ (R, G, B)
      axesHelper.geometry.attributes.color.array.set([0, 1, 0], 9); // çµ‚ç‚¹ (R, G, B)

      // Zè»¸å…¨ä½“ã‚’é’ã«è¨­å®š
      axesHelper.geometry.attributes.color.array.set([0, 0, 1], 12); // å§‹ç‚¹ (R, G, B)
      axesHelper.geometry.attributes.color.array.set([0, 0, 1], 15); // çµ‚ç‚¹ (R, G, B)
      // è‰²ã®å¤‰æ›´ã‚’æœ‰åŠ¹åŒ–
      axesHelper.geometry.attributes.color.needsUpdate = true;
  }


    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    

    function animate(){
      requestAnimationFrame(animate);

      //pointLight.intensity = controls.lightIntensity;
      //pointLight.distance = controls.lightDistance;

      //createRectLight.intensity = controls.lightIntensity;
      //createRectLight.distance = controls.lightDistance;


      //const b = Math.round(255 * controls.lightIntensity);
      //sphere.children[0].material.color = new THREE.Color(`rgb(${b}, ${b}, ${b})`);

      /*let newLightColor = {};
      Object.keys(lightPanel.material.color).forEach(channel => {
        newLightColor[channel] = new THREE.Color(controls.lightColor)[channel] * controls.lightIntensity;
      });
      lightPanel.material.color = newLightColor;
      */
      
/*
      let new_createRectLight = {};
      Object.keys(createRectLight.material.color).forEach(channel => {
        new_createRectLight[channel] = new THREE.Color(controls.lightColor)[channel] * controls.lightIntensity;
      });
      createRectLight.material.color = new_createLightPanelSet;*/

      stats.update();
      CamControls.update();
      renderer.render(scene, camera);
    }
    animate();

    function size(){
      //camera.aspect = window.innerWidth / window.innerHeight;
      //renderer.setSize(window.innerWidth, window.innerHeight);

      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    size();
    onresize = size;  
  </script>
</body>
</html>