<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Three.js - Basic Cube</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
      }

      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
      }
    }
  </script>

<script type="module">
  // basic コピペ ->編集中
  import * as THREE from 'three';
  import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';

  const canvas = document.querySelector( '#c' );
  const renderer = new THREE.WebGLRenderer( { antialias: true, canvas } );
  renderer.setPixelRatio(window.devicePixelRatio); // 高解像度対応
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Resize handling
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); 
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});



  /* カメラの実装 */
  // カメラはデフォルトで、Yを上にして-Z軸を見下ろします。
  const camera = new THREE.PerspectiveCamera(
    40, //fov: 垂直方向に75度
    window.innerWidth / window.innerHeight, //aspect: デフォルトは300/150
    // 300x150pixel
    0.1, // near
    1000 // far
    // nearとfarはレンダリングされるカメラの前のスペース
  );
  //camera.position.z = 50; //8
  camera.position.set(0, 20, 20);
  camera.lookAt(0, 0, 0); 
    
    /*シーンの構築*/
    const scene = new THREE.Scene();
    
    /* シーンの背景色を変更 */
    scene.background = new THREE.Color(0xAAAAAA); // ライトグレーの背景　背景色を16進数で設定　　0xffffff 0xAAAAAA
    
      {
        /* ライトの実装 */
        const color = 0xFFFFFF;                                     // 光の色
        const intensity = 3;                                        // 光の強度
        const light = new THREE.DirectionalLight(color, intensity); // ライトの生成
        light.position.set(-1, 2, 4);                                // ライトの配置
        scene.add(light);
      }
      
      

  //create a blue LineBasicMaterial
  const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );

  const points = [];
  points.push( new THREE.Vector3( - 10, 0, 0 ) );
  points.push( new THREE.Vector3( 0, 10, 0 ) );
  points.push( new THREE.Vector3( 10, 0, 0 ) );
  
  const geometry = new THREE.BufferGeometry().setFromPoints( points );

  const line = new THREE.Line( geometry, material );

      {
        //軸を追加する。
        const axesHelper = new THREE.AxesHelper(8); 
        // X軸:赤 Y軸:緑 Z軸:青
        scene.add(axesHelper);

        // X軸全体を赤に設定
        axesHelper.geometry.attributes.color.array.set([1, 0, 0], 0); // 始点 (R, G, B)
        axesHelper.geometry.attributes.color.array.set([1, 0, 0], 3); // 終点 (R, G, B)

        // Y軸全体を緑に設定
        axesHelper.geometry.attributes.color.array.set([0, 1, 0], 6); // 始点 (R, G, B)
        axesHelper.geometry.attributes.color.array.set([0, 1, 0], 9); // 終点 (R, G, B)

        // Z軸全体を青に設定
        axesHelper.geometry.attributes.color.array.set([0, 0, 1], 12); // 始点 (R, G, B)
        axesHelper.geometry.attributes.color.array.set([0, 0, 1], 15); // 終点 (R, G, B)
        // 色の変更を有効化
        axesHelper.geometry.attributes.color.needsUpdate = true;


        //グリッドを追加する。
        //const gridHelper = new THREE.GridHelper(20, 300) //, 0x0000ff
        // GridHelper (サイズ、分割数、colorCenterLine、colorGrid)
        //scene.add(gridHelper);
      }


  scene.add( line );
  renderer.render( scene, camera );
    

    </script>
  </body>
</html>